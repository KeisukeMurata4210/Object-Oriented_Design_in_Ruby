継承の階層構造、モジュールの利用性・メンテナンス性は、そのままコードの質になる

アンチパターン①
オブジェクトがtype,categoryなどの変数名を使い、selfにどんなメッセージを送るか決めている。
→関連性は高いが型の異なるオブジェクトが含まれている。
　→共通のコードは抽象スーパークラスに置き、サブクラスで違う型を作る。
　 既存のコードを変えずにサブクラスで拡張できる。

アンチパターン②
メッセージを受け取るオブジェクトのクラスを確認してから、どのメッセージを送るかをオブジェクトが決めている。
→ダックタイプを見落としている。
　→ダックタイプがインターフェースだけでなく振る舞いも共有する場合は、モジュールを使う

☆抽象に固執する
抽象スーパークラス内のコードを使わないサブクラスがあってはならない。
この制約はモジュールでも同様。
なぜなら、抽象クラスを継承するオブジェクトに間違った振る舞いが含まれる原因になるから。
この間違った振る舞いを避けようとする過程で、コードが崩壊していく。
コードの知識への依存は避けるべき。

サブクラスで「実装していない」という例外を投げるようにオーバーライドする場合は、この問題を犯している。
サブクラスで「そんなことはやらない」と宣言するのは、「そのサブクラスではない」と宣言するようなもの。
抽象を絞り込めなかったり、抽象化できる共通のコードが存在しない場合は、継承が問題解決にならない時。

☆契約を守る
サブクラスは、スーパークラスと置換できることを約束する＝契約
サブクラスはスーパークラスのインターフェースに含まれるどのメッセージが来ても応えられるべきで、
同じ種類の入出力ができるべき。
型を識別しないと使えないサブクラスは、サブクラスとして使えない。

スーパークラスが使えるところではサブクラスも使える。

☆テンプレートメソッドパターンを使う
抽象と具象を分ける。
抽象コードでアルゴリズムを定義し、具象では、テンプレート化されたメソッドをオーバーライドすることで特化する。
テンプレートメソッドは、変化する場所を表す
　=> このパターンを使うことで、変化する/しないものを明確に決めざるを得なくなる。

☆前もって疎結合にする
superを呼び出すコードは避ける。代わりにフックメッセージを使う。
サブクラスがスーパークラスを知っておく責任を避けつつアルゴリズムに加われる。
→これが使えるのは、階層が隣接している場合。２つ以上の階層になると、オーバーライドした上でsuperを呼び出す必要がある。

☆階層構造は浅くする。
浅く狭い < 浅く広い < 深く狭い < 深く広い
の順で分かりづらくなる。

階層が深い場合、探索パスが長くなる。= 依存が多くなる。
プログラマーは底辺と頂点のみを見がち。= 中間層のクラスに変更があった場合、エラーが起きやすくなる。
