第1章　オブジェクト指向設計
・ソフトウェアは機能の追加などで変わり続けるため、今必要な機能を無駄なく記述するだけでなく、変更しやすい設計にすることが必要。
・設計されてないコードは、開発が進むにつれて苦痛が大きくなっていく。
・変更しづらいというのは、一箇所を変えると飛び火してあちこちを変えないといけないコード。


第2章　単一責任のクラスを設計する
・クラス、メソッドは単一責任（目的が一つだけ）にする。
・クラスとクラスは疎結合にする。片方が変わるともう片方も変える必要が出るのは良くない。


第3章　依存関係を整理する


第4章　柔軟なインターフェースをつくる
・クラスと、そのクラスが何を知っているか
   よりも、メッセージを誰に送るか、という視点で設計する。
   ・「どのように 」より  「何を」にフォーカスしてメッセージを送る。  レストランで注文する時、「何を」食べたいかを伝えてその料理を受け取ればいいのであって、その料理を「どのように」調理するかは知らなくて良い。
・↑の一つの方法が、自分自身（インスタンス）を渡して
・メソッドチェーンがあまり好ましくないのは、↑↑と同じで記述されるオブジェクトが処理を知りすぎて
　いることと、特定の実装に縛られてしまうから。
・設計を見直す基準：シーケンス図がコードと同じかそれ以上に難しいとき、設計の何かがおかしい


第5章　ダックタイピングでコストを削減する
・ポリモーフィズム：多岐にわたるオブジェクトが、同じメッセージに応答できること。
・ダックタイプ：振る舞いに着目し、オブジェクトを入れ替えても問題なく動作するコード
・継承：メッセージを受け取り、理解できなければスーパークラスにメッセージを送る、という仕組み
・抽象クラス：サブクラス間で共有される振る舞いの共通の格納場所を提供する。
・↑サブクラスが複数必要にならない限り作る意味がない。複数必要になったとしても、複製のコストとの
　兼ね合いを考える。
・「間違ったとき何が起こるだろう？」具象クラスから抽象クラスに押し上げる書き方をすれば、具象
　クラスに抽象的な要素を残してしまったとしても問題は起きない。逆向きだと正しい継承ができない。
・スーパー/サブクラスでも、相手オブジェクトのアルゴリズムに依存したコードを書かないというルール
　は変わらない
・↑のテクニックとして、サブクラスがスーパークラスのアルゴリズムを前提にsuperを送るのではなく、
　スーパークラスがフックメッセージを送るようにする
・↑スーパークラスから、自身に定義されたダミーのメソッドにメッセージを送るようにし、サブクラスに
　同名のメソッドを持たせる。